{"version":3,"sources":["MessageBus.js","/home/ilia/code/MessageBus/MessageBus.ts"],"names":["MessageBus","_MessageBus","MessageBus.create","MessageBus.MessageBus","MessageBus.MessageBus.constructor","MessageBus.MessageBus.close","MessageBus.MessageBus.on","MessageBus.MessageBus.off","MessageBus.MessageBus.emit","MessageBus.MessageBus._channelExists","MessageBus.MessageBus._onEvent"],"mappings":"AAAA,YCAA,IAAOA,aAAP,SAAOC,GDqFH,QCyBcD,GAAOA,GACrBE,MAAOA,IAAIA,GAAWA,GAnGxBF,GAAaA,GAAUA,WAWrBG,QAXWA,GAWCA,GAXdC,GAAAA,GAAAA,IAEUA,MAAAA,aACAA,KAAAA,UAAwBA,KAU9BA,KAAKA,UAAYA,CAEjBA,IAAIA,GAAYA,SAAAA,GAAKA,MAAAA,GAAKA,SAASA,EAAEA,KAAKA,KAAMA,EAAEA,KAAKA,UACnDA,EAAYA,SAAAA,GAAKA,MAAAA,GAAKA,SAASA,QAASA,GAE5CA,GAASA,iBAAiBA,UAAWA,GACrCA,EAASA,iBAAiBA,QAASA,GAEnCA,KAAKA,UAAYA,WACfA,EAASA,oBAAoBA,UAAWA,GACxCA,EAASA,oBAAoBA,QAASA,IAoE5CD,MA3DEA,GAAAA,UAAAA,MAAAA,WACyBE,OAAnBA,KAAKA,WACPA,KAAKA,YAEPA,KAAKA,UAAYA,KACjBA,KAAKA,cASPF,EAAAA,UAAAA,GAAAA,SAAGA,EAAcA,GACVG,KAAKA,eAAeA,KACvBA,KAAKA,UAAUA,OAEjBA,KAAKA,UAAUA,GAAMA,KAAKA,IAS5BH,EAAAA,UAAAA,IAAAA,SAAIA,EAAcA,GAChBI,GAAIA,KAAKA,eAAeA,GAAOA,CAC7BA,GAAIA,GAAUA,KAAKA,UAAUA,GACzBA,EAAUA,EAAQA,QAAQA,EAChBA,MAAVA,GACFA,EAAQA,OAAOA,EAAOA,KAW5BJ,EAAAA,UAAAA,KAAAA,SAAKA,EAAcA,GACjBK,KAAKA,UAAUA,aAAcA,KAAAA,EAAMA,QAAAA,KAG7BL,EAAAA,UAAAA,eAARA,SAAuBA,GACrBM,MAAOA,MAAKA,UAAUA,eAAeA,IAG/BN,EAAAA,UAAAA,SAARA,SAAiBA,EAAcA,GACzBO,KAAKA,eAAeA,IACtBA,KAAKA,UAAUA,GAAMA,QAAQA,SAACA,GAC5BA,EAASA,MAKjBP,IA3FaH,GAAAA,WAAAA,EAkGGA,EAAAA,OAAAA,GA9GXA,aAAAA","file":"MessageBus.js","sourcesContent":["var MessageBus;\n(function (_MessageBus) {\n    var MessageBus = (function () {\n        /**\n         * Wrap an `Endpoint` and provide a pubsub interface.\n         *\n         * @param endpoint WebWorker endpoint\n         */\n        function MessageBus(endpoint) {\n            var _this = this;\n            this._channels = {};\n            this._unlisten = null;\n            this._endpoint = endpoint;\n            let onMessage = function (e) { return _this._onEvent(e.data.name, e.data.payload); }, onError = function (e) { return _this._onEvent(\"error\", e); };\n            endpoint.addEventListener(\"message\", onMessage);\n            endpoint.addEventListener(\"error\", onError);\n            this._unlisten = function () {\n                endpoint.removeEventListener(\"message\", onMessage);\n                endpoint.removeEventListener(\"error\", onError);\n            };\n        }\n        /**\n         * Remove event listeners from supplied `Endpoint`\n         * Delete all listeners from `MessageBus`\n         */\n        MessageBus.prototype.close = function () {\n            if (this._unlisten !== null) {\n                this._unlisten();\n            }\n            this._unlisten = null;\n            this._channels = {};\n        };\n        /**\n         * Listener on channel\n         *\n         * @param name Channel to listen on\n         * @param listener Callback function\n         */\n        MessageBus.prototype.on = function (name, listener) {\n            if (!this._channelExists(name)) {\n                this._channels[name] = [];\n            }\n            this._channels[name].push(listener);\n        };\n        /**\n         * Unlisten from channel\n         *\n         * @param name Channel to unlisten\n         * @param listener Callback function\n         */\n        MessageBus.prototype.off = function (name, listener) {\n            if (this._channelExists(name)) {\n                let channel = this._channels[name], index = channel.indexOf(listener);\n                if (index !== -1) {\n                    channel.splice(index, 1);\n                }\n            }\n        };\n        /**\n         * Emit a message on a channel\n         *\n         * @param name Channel name\n         * @param payload Message data\n         */\n        MessageBus.prototype.emit = function (name, payload) {\n            this._endpoint.postMessage({ name, payload });\n        };\n        MessageBus.prototype._channelExists = function (name) {\n            return this._channels.hasOwnProperty(name);\n        };\n        MessageBus.prototype._onEvent = function (name, payload) {\n            if (this._channelExists(name)) {\n                this._channels[name].forEach(function (listener) {\n                    listener(payload);\n                });\n            }\n        };\n        return MessageBus;\n    })();\n    _MessageBus.MessageBus = MessageBus;\n    /**\n     * Factory function for creating a `MessageBus`\n     *\n     * @param endpoint WebWorker endpoint\n     */\n    function create(endpoint) {\n        return new MessageBus(endpoint);\n    }\n    _MessageBus.create = create;\n})(MessageBus || (MessageBus = {}));\n","module MessageBus {\n\n  export interface Endpoint {\n    postMessage(message: any): void;\n    addEventListener(type: string, listener: (ev: any) => any): any;\n    removeEventListener(type: string, listener: (ev: any) => any): any;\n  }\n\n  export interface Listener {\n    (payload?: any): any;\n  }\n\n  export class MessageBus {\n\n    private _channels: { [name: string]: Array<Listener> } = {};\n    private _unlisten: () => void = null\n    private _endpoint: Endpoint;\n\n    /**\n     * Wrap an `Endpoint` and provide a pubsub interface.\n     *\n     * @param endpoint WebWorker endpoint\n     */\n    constructor(endpoint: Endpoint) {\n\n      this._endpoint = endpoint;\n\n      let onMessage = e => this._onEvent(e.data.name, e.data.payload),\n          onError   = e => this._onEvent(\"error\", e);\n\n      endpoint.addEventListener(\"message\", onMessage);\n      endpoint.addEventListener(\"error\", onError);\n\n      this._unlisten = () => {\n        endpoint.removeEventListener(\"message\", onMessage);\n        endpoint.removeEventListener(\"error\", onError);\n      };\n\n    }\n\n    /**\n     * Remove event listeners from supplied `Endpoint`\n     * Delete all listeners from `MessageBus`\n     */\n    close(): void {\n      if (this._unlisten !== null) {\n        this._unlisten();\n      }\n      this._unlisten = null;\n      this._channels = {};\n    }\n\n    /**\n     * Listener on channel\n     * \n     * @param name Channel to listen on\n     * @param listener Callback function\n     */\n    on(name: string, listener: Listener): void {\n      if (!this._channelExists(name)) {\n        this._channels[name] = [];\n      }\n      this._channels[name].push(listener);\n    }\n\n    /**\n     * Unlisten from channel\n     * \n     * @param name Channel to unlisten\n     * @param listener Callback function\n     */\n    off(name: string, listener: Listener): void {\n      if (this._channelExists(name)) {\n        let channel = this._channels[name],\n            index   = channel.indexOf(listener);\n        if (index !== -1) {\n          channel.splice(index, 1);\n        }\n      }\n    }\n\n    /**\n     * Emit a message on a channel\n     * \n     * @param name Channel name\n     * @param payload Message data\n     */\n    emit(name: string, payload?: any): void {\n      this._endpoint.postMessage({ name, payload });\n    }\n\n    private _channelExists(name: string): boolean {\n      return this._channels.hasOwnProperty(name);\n    }\n\n    private _onEvent(name: string, payload: any): void {\n      if (this._channelExists(name)) {\n        this._channels[name].forEach((listener) => {\n          listener(payload);\n        });\n      }\n    }\n\n  }\n\n  /**\n   * Factory function for creating a `MessageBus`\n   *\n   * @param endpoint WebWorker endpoint\n   */\n  export function create(endpoint: Endpoint): MessageBus {\n    return new MessageBus(endpoint);\n  }\n}\n"],"sourceRoot":"/source/"}